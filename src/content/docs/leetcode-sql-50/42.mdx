---
title: Investments in 2016
description: Investments in 2016
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Medium" variant="note" />
<Badge text="Window Functions" variant="note" />

Hitung total investasi 2016 untuk policyholder yang punya `tiv_2015` sama dengan orang lain tapi lokasi unik menggunakan window function `COUNT() OVER(PARTITION BY)` dan filtering.

https://leetcode.com/problems/investments-in-2016

## Soal

> Table: `Insurance`
>
> ```
> +-------------+-------+
> | Column Name | Type  |
> +-------------+-------+
> | pid         | int   |
> | tiv_2015    | float |
> | tiv_2016    | float |
> | lat         | float |
> | lon         | float |
> +-------------+-------+
> ```
>
> `pid` is the primary key (column with unique values) for this table.
>
> Each row of this table contains information about one policy where:
>
> - `pid` is the policyholder's policy ID.
> - `tiv_2015` is the total investment value in 2015 and `tiv_2016` is the total investment value in 2016.
> - `lat` is the latitude of the policy holder's city. It's guaranteed that `lat` is not NULL.
> - `lon` is the longitude of the policy holder's city. It's guaranteed that `lon` is not NULL.

Write a solution to report the sum of all total investment values in 2016 `tiv_2016`, for all policyholders who:

- have the same `tiv_2015` value as one or more other policyholders, and
- are not located in the same city as any other policyholder (i.e., the (`lat`, `lon`) attribute pairs must be unique).

Round `tiv_2016` to two decimal places.

The result format is in the following example.

> **Example 1:**
>
> Input:
>
> `Insurance` table:
>
> ```
> +-----+----------+----------+-----+-----+
> | pid | tiv_2015 | tiv_2016 | lat | lon |
> +-----+----------+----------+-----+-----+
> | 1   | 10       | 5        | 10  | 10  |
> | 2   | 20       | 20       | 20  | 20  |
> | 3   | 10       | 30       | 20  | 20  |
> | 4   | 10       | 40       | 40  | 40  |
> +-----+----------+----------+-----+-----+
> ```
>
> Output:
>
> ```
> +----------+
> | tiv_2016 |
> +----------+
> | 45.00    |
> +----------+
> ```
>
> **Explanation:**
>
> - The first record in the table, like the last record, meets both of the two criteria.
> - The `tiv_2015` value 10 is the same as the third and fourth records, and its location is unique.
> - The second record does not meet any of the two criteria. Its `tiv_2015` is not like any other policyholders and its location is the same as the third record, which makes the third record fail, too.
> - So, the result is the sum of `tiv_2016` of the first and last record, which is 45.

## Setup Soal

Buat tabel dan insert data contoh:

```sql
CREATE TABLE Insurance (
    pid INT PRIMARY KEY,
    tiv_2015 FLOAT,
    tiv_2016 FLOAT,
    lat FLOAT NOT NULL,
    lon FLOAT NOT NULL
);

INSERT INTO Insurance (pid, tiv_2015, tiv_2016, lat, lon) VALUES
    (1, 10, 5, 10, 10),
    (2, 20, 20, 20, 20),
    (3, 10, 30, 20, 20),
    (4, 10, 40, 40, 40);
```

## Jawaban SQL

```sql
WITH insurance1 AS (
    SELECT
        *,
        COUNT(*) OVER(PARTITION BY tiv_2015) AS num_same_tiv_2015,
        COUNT(*) OVER(PARTITION BY lat, lon) AS num_same_lat_lon
    FROM Insurance
),

insurance2 AS (
    SELECT *
    FROM insurance1
    WHERE
        num_same_tiv_2015 > 1
        AND num_same_lat_lon = 1
)

SELECT ROUND(SUM(tiv_2016)::NUMERIC, 2) AS tiv_2016
FROM insurance2;
```

## Penjelasan

Soal ini meminta kita mencari policyholder yang memenuhi 2 kriteria sekaligus:
1. Punya `tiv_2015` yang **sama** dengan minimal 1 orang lain
2. Punya lokasi (`lat`, `lon`) yang **unik** (tidak ada orang lain di lokasi yang sama)

Kita akan menggunakan 2 CTE untuk memisahkan logic menjadi 2 tahap yang jelas:
- **CTE 1 (`insurance1`)**: Tambahkan informasi "berapa orang dengan `tiv_2015` sama" dan "berapa orang di lokasi sama"
- **CTE 2 (`insurance2`)**: Filter hanya yang memenuhi kedua kriteria

:::note
Query ini menggunakan 2 CTE untuk memisahkan tahap perhitungan dan filtering. Ini membuat flow query lebih mudah dipahami: tambah kolom counter → filter berdasarkan counter → hitung total.
:::

Mari kita breakdown query-nya step by step:

### 1. CTE Pertama: Tambah Kolom Counter dengan Window Function

```sql
WITH insurance1 AS (
    SELECT
        *,
        COUNT(*) OVER(PARTITION BY tiv_2015) AS num_same_tiv_2015,
        COUNT(*) OVER(PARTITION BY lat, lon) AS num_same_lat_lon
    FROM Insurance
)
```

CTE ini menambahkan 2 kolom baru menggunakan window function:

**`COUNT(*) OVER(PARTITION BY tiv_2015)`**
- Menghitung berapa banyak baris yang punya `tiv_2015` yang sama
- `PARTITION BY tiv_2015` artinya: kelompokkan berdasarkan `tiv_2015`, lalu hitung jumlah baris di setiap kelompok

**`COUNT(*) OVER(PARTITION BY lat, lon)`**
- Menghitung berapa banyak baris yang punya lokasi (`lat`, `lon`) yang sama
- `PARTITION BY lat, lon` artinya: kelompokkan berdasarkan kombinasi `lat` dan `lon`, lalu hitung jumlah baris di setiap kelompok

Hasil CTE `insurance1`:

```
+-----+----------+----------+-----+-----+--------------------+------------------+
| pid | tiv_2015 | tiv_2016 | lat | lon | num_same_tiv_2015  | num_same_lat_lon |
+-----+----------+----------+-----+-----+--------------------+------------------+
| 1   | 10       | 5        | 10  | 10  | 3                  | 1                |
| 2   | 20       | 20       | 20  | 20  | 1                  | 2                |
| 3   | 10       | 30       | 20  | 20  | 3                  | 2                |
| 4   | 10       | 40       | 40  | 40  | 3                  | 1                |
+-----+----------+----------+-----+-----+--------------------+------------------+
```

Penjelasan:
- **pid 1**: `tiv_2015 = 10` ada 3 orang (pid 1, 3, 4), lokasi `(10, 10)` cuma dia sendiri
- **pid 2**: `tiv_2015 = 20` cuma dia sendiri, lokasi `(20, 20)` ada 2 orang (pid 2, 3)
- **pid 3**: `tiv_2015 = 10` ada 3 orang (pid 1, 3, 4), lokasi `(20, 20)` ada 2 orang (pid 2, 3)
- **pid 4**: `tiv_2015 = 10` ada 3 orang (pid 1, 3, 4), lokasi `(40, 40)` cuma dia sendiri

### 2. CTE Kedua: Filter yang Memenuhi Kriteria

```sql
insurance2 AS (
    SELECT *
    FROM insurance1
    WHERE
        num_same_tiv_2015 > 1
        AND num_same_lat_lon = 1
)
```

Sekarang kita filter hanya yang memenuhi kedua kriteria:
- `num_same_tiv_2015 > 1`: Ada minimal 2 orang dengan `tiv_2015` yang sama (termasuk dirinya sendiri)
- `num_same_lat_lon = 1`: Cuma dia sendiri di lokasi tersebut (lokasi unik)

Hasil CTE `insurance2`:

```
+-----+----------+----------+-----+-----+--------------------+------------------+
| pid | tiv_2015 | tiv_2016 | lat | lon | num_same_tiv_2015  | num_same_lat_lon |
+-----+----------+----------+-----+-----+--------------------+------------------+
| 1   | 10       | 5        | 10  | 10  | 3                  | 1                | ✓
| 4   | 10       | 40       | 40  | 40  | 3                  | 1                | ✓
+-----+----------+----------+-----+-----+--------------------+------------------+
```

Yang lolos:
- **pid 1**: `tiv_2015` ada 3 orang (✓) dan lokasi unik (✓)
- **pid 4**: `tiv_2015` ada 3 orang (✓) dan lokasi unik (✓)

Yang tidak lolos:
- **pid 2**: `tiv_2015` cuma dia sendiri (✗)
- **pid 3**: Lokasi tidak unik, ada pid 2 di lokasi yang sama (✗)

### 3. Hitung Total tiv_2016

```sql
SELECT ROUND(SUM(tiv_2016)::NUMERIC, 2) AS tiv_2016
FROM insurance2
```

Terakhir, kita jumlahkan `tiv_2016` dari policyholder yang lolos filter:

```
SUM(tiv_2016) = 5 + 40 = 45
ROUND(45, 2) = 45.00
```

Hasil akhir:

```
+----------+
| tiv_2016 |
+----------+
| 45.00    |
+----------+
```

## Referensi

- `WITH` (CTE): Membuat temporary result set yang bisa direferensikan dalam query utama.
- `SELECT`: Memilih kolom yang akan ditampilkan.
- `FROM`: Menentukan tabel sumber data.
- `WHERE`: Memfilter baris berdasarkan kondisi.
- `COUNT(*)`: Menghitung jumlah baris.
- `SUM()`: Menghitung total nilai.
- `ROUND(value, decimal_places)`: Membulatkan nilai ke jumlah desimal tertentu.
- `::NUMERIC`: Cast value ke tipe data `NUMERIC` untuk presisi lebih tinggi.
- `OVER()`: Clause untuk mendefinisikan window dalam window function.
- `PARTITION BY`: Membagi data menjadi partisi untuk perhitungan window function.
- Window Function: Fungsi yang melakukan perhitungan pada sekumpulan baris yang terkait dengan baris saat ini.
- `AND`: Operator logika untuk menggabungkan kondisi (semua harus true).
