---
title: Friend Requests II - Who Has the Most Friends
description: Friend Requests II - Who Has the Most Friends
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Medium" variant="note" />
<Badge text="Subqueries" variant="note" />

Cari orang yang punya teman paling banyak dengan menghitung jumlah friend request yang dikirim dan diterima menggunakan multiple CTE, `FULL JOIN`, `COALESCE()`, dan `ORDER BY` dengan `LIMIT`.

https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends

## Soal

> Table: `RequestAccepted`
>
> ```
> +----------------+---------+
> | Column Name    | Type    |
> +----------------+---------+
> | requester_id   | int     |
> | accepter_id    | int     |
> | accept_date    | date    |
> +----------------+---------+
> ```
>
> (`requester_id`, `accepter_id`) is the primary key (combination of columns with unique values) for this table.
>
> This table contains the ID of the user who sent the request, the ID of the user who received the request, and the date when the request was accepted.

Write a solution to find the people who have the most friends and the most friends number.

The test cases are generated so that only one person has the most friends.

The result format is in the following example.

> **Example 1:**
>
> Input:
>
> `RequestAccepted` table:
>
> ```
> +--------------+-------------+-------------+
> | requester_id | accepter_id | accept_date |
> +--------------+-------------+-------------+
> | 1            | 2           | 2016/06/03  |
> | 1            | 3           | 2016/06/08  |
> | 2            | 3           | 2016/06/08  |
> | 3            | 4           | 2016/06/09  |
> +--------------+-------------+-------------+
> ```
>
> Output:
>
> ```
> +----+-----+
> | id | num |
> +----+-----+
> | 3  | 3   |
> +----+-----+
> ```
>
> **Explanation:**
>
> The person with id 3 is a friend of people 1, 2, and 4, so he has three friends in total, which is the most number than any others.

## Setup Soal

Buat tabel dan insert data contoh:

```sql
CREATE TABLE RequestAccepted (
    requester_id INT,
    accepter_id INT,
    accept_date DATE,
    PRIMARY KEY (requester_id, accepter_id)
);

INSERT INTO RequestAccepted (requester_id, accepter_id, accept_date) VALUES
    (1, 2, '2016-06-03'),
    (1, 3, '2016-06-08'),
    (2, 3, '2016-06-08'),
    (3, 4, '2016-06-09');
```

## Jawaban SQL

```sql
WITH requester AS (
    SELECT
        requester_id AS id,
        COUNT(*) AS count
    FROM RequestAccepted
    GROUP BY requester_id
),

accepter AS (
    SELECT
        accepter_id AS id,
        COUNT(*) AS count
    FROM RequestAccepted
    GROUP BY accepter_id
),

total AS (
    SELECT
        COALESCE(r.id, a.id) AS id,
        COALESCE(r.count, 0) + COALESCE(a.count, 0) AS num
    FROM requester r
    FULL JOIN accepter a ON r.id = a.id
)

SELECT *
FROM total
ORDER BY num DESC
LIMIT 1;
```

## Penjelasan

Soal ini meminta kita mencari orang yang punya teman paling banyak. Yang tricky di sini adalah: seseorang bisa jadi teman dengan dua cara - sebagai **requester** (yang mengirim request) atau sebagai **accepter** (yang menerima request). Jadi kita harus menghitung keduanya.

Mari kita breakdown query-nya step by step:

### 1. CTE Pertama: Hitung Sebagai Requester

```sql
WITH requester AS (
    SELECT
        requester_id AS id,
        COUNT(*) AS count
    FROM RequestAccepted
    GROUP BY requester_id
)
```

CTE ini fokus menghitung: **berapa kali seseorang mengirim friend request yang diterima?**

Hasil CTE `requester`:

```
+----+-------+
| id | count |
+----+-------+
| 1  | 2     | <- User 1 mengirim request ke 2 orang (user 2 dan 3)
| 2  | 1     | <- User 2 mengirim request ke 1 orang (user 3)
| 3  | 1     | <- User 3 mengirim request ke 1 orang (user 4)
+----+-------+
```

### 2. CTE Kedua: Hitung Sebagai Accepter

```sql
accepter AS (
    SELECT
        accepter_id AS id,
        COUNT(*) AS count
    FROM RequestAccepted
    GROUP BY accepter_id
)
```

CTE ini fokus menghitung: **berapa kali seseorang menerima friend request?**

Hasil CTE `accepter`:

```
+----+-------+
| id | count |
+----+-------+
| 2  | 1     | <- User 2 menerima request dari 1 orang (user 1)
| 3  | 2     | <- User 3 menerima request dari 2 orang (user 1 dan 2)
| 4  | 1     | <- User 4 menerima request dari 1 orang (user 3)
+----+-------+
```

:::note
Query ini menggunakan 3 CTE terpisah (`requester`, `accepter`, `total`) untuk memisahkan logic menjadi bagian-bagian kecil. Ini membuat flow query lebih mudah dipahami: hitung requester → hitung accepter → gabungkan keduanya.
:::

### 3. CTE Ketiga: Gabungkan dengan FULL JOIN

```sql
total AS (
    SELECT
        COALESCE(r.id, a.id) AS id,
        COALESCE(r.count, 0) + COALESCE(a.count, 0) AS num
    FROM requester r
    FULL JOIN accepter a ON r.id = a.id
)
```

Sekarang kita gabungkan kedua CTE dengan `FULL JOIN` untuk mendapatkan total teman setiap orang.

**Kenapa FULL JOIN?**

Karena ada kemungkinan:
- Seseorang hanya sebagai requester (tidak pernah menerima request)
- Seseorang hanya sebagai accepter (tidak pernah mengirim request)
- Seseorang sebagai keduanya

`FULL JOIN` memastikan kita tidak kehilangan data dari kedua sisi.

Hasil setelah `FULL JOIN`:

```
+----+---------+---------+
| id | r.count | a.count |
+----+---------+---------+
| 1  | 2       | NULL    | <- User 1 hanya requester
| 2  | 1       | 1       | <- User 2 requester dan accepter
| 3  | 1       | 2       | <- User 3 requester dan accepter
| 4  | NULL    | 1       | <- User 4 hanya accepter
+----+---------+---------+
```

**COALESCE untuk Handle NULL:**

- `COALESCE(r.id, a.id)`: Ambil `r.id` kalau ada, kalau `NULL` ambil `a.id`
- `COALESCE(r.count, 0)`: Ubah `NULL` jadi `0` agar bisa dijumlahkan
- `COALESCE(a.count, 0)`: Ubah `NULL` jadi `0` agar bisa dijumlahkan

Hasil CTE `total`:

```
+----+-----+
| id | num |
+----+-----+
| 1  | 2   | <- 2 + 0 = 2 teman
| 2  | 2   | <- 1 + 1 = 2 teman
| 3  | 3   | <- 1 + 2 = 3 teman (TERBANYAK!)
| 4  | 1   | <- 0 + 1 = 1 teman
+----+-----+
```

### 4. Ambil yang Paling Banyak

```sql
SELECT *
FROM total
ORDER BY num DESC
LIMIT 1
```

Urutkan berdasarkan `num` dari terbesar ke terkecil, lalu ambil 1 baris pertama.

Hasil akhir:

```
+----+-----+
| id | num |
+----+-----+
| 3  | 3   |
+----+-----+
```

User 3 punya 3 teman (user 1, 2, dan 4), yang merupakan jumlah terbanyak.

## Referensi

- `WITH` (CTE): Membuat temporary result set yang bisa direferensikan dalam query utama.
- `SELECT`: Memilih kolom yang akan ditampilkan.
- `FROM`: Menentukan tabel sumber data.
- `GROUP BY`: Mengelompokkan baris berdasarkan nilai kolom tertentu.
- `COUNT(*)`: Menghitung jumlah baris dalam setiap grup.
- `FULL JOIN`: Menggabungkan dua tabel dengan mempertahankan semua baris dari kedua tabel.
- `ON`: Menentukan kondisi untuk menggabungkan baris dari kedua tabel.
- `COALESCE(value1, value2, ...)`: Mengembalikan nilai pertama yang tidak `NULL`.
- `ORDER BY`: Mengurutkan hasil query.
- `LIMIT n`: Membatasi hasil query hanya n baris pertama.
- `AS`: Memberi alias untuk kolom atau tabel.
- Multiple CTE: Teknik membuat beberapa CTE dalam satu query untuk separation of concern.
