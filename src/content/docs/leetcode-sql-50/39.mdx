---
title: Movie Rating
description: Movie Rating
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Medium" variant="note" />
<Badge text="Subquery" variant="note" />

Temukan user dengan review terbanyak dan movie dengan rating tertinggi di bulan tertentu menggunakan 2 CTE dengan `UNION ALL`.

https://leetcode.com/problems/movie-rating

## Soal

> Table: `Movies`
>
> ```
> +---------------+---------+
> | Column Name   | Type    |
> +---------------+---------+
> | movie_id      | int     |
> | title         | varchar |
> +---------------+---------+
> ```
>
> `movie_id` is the primary key (column with unique values) for this table.
>
> `title` is the name of the movie. Each movie has a unique title.

> Table: `Users`
>
> ```
> +---------------+---------+
> | Column Name   | Type    |
> +---------------+---------+
> | user_id       | int     |
> | name          | varchar |
> +---------------+---------+
> ```
>
> `user_id` is the primary key (column with unique values) for this table.
>
> The column 'name' has unique values.

> Table: `MovieRating`
>
> ```
> +---------------+---------+
> | Column Name   | Type    |
> +---------------+---------+
> | movie_id      | int     |
> | user_id       | int     |
> | rating        | int     |
> | created_at    | date    |
> +---------------+---------+
> ```
>
> (`movie_id`, `user_id`) is the primary key (column with unique values) for this table.
>
> This table contains the rating of a movie by a user in their review.
>
> `created_at` is the user's review date.

Write a solution to:

1. Find the **name of the user** who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name.
2. Find the **movie name** with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name.

The result format is in the following example.

> **Example 1:**
>
> Input:
>
> `Movies` table:
>
> ```
> +-------------+--------------+
> | movie_id    |  title       |
> +-------------+--------------+
> | 1           | Avengers     |
> | 2           | Frozen 2     |
> | 3           | Joker        |
> +-------------+--------------+
> ```
>
> `Users` table:
>
> ```
> +-------------+--------------+
> | user_id     |  name        |
> +-------------+--------------+
> | 1           | Daniel       |
> | 2           | Monica       |
> | 3           | Maria        |
> | 4           | James        |
> +-------------+--------------+
> ```
>
> `MovieRating` table:
>
> ```
> +-------------+--------------+--------------+-------------+
> | movie_id    | user_id      | rating       | created_at  |
> +-------------+--------------+--------------+-------------+
> | 1           | 1            | 3            | 2020-01-12  |
> | 1           | 2            | 4            | 2020-02-11  |
> | 1           | 3            | 2            | 2020-02-12  |
> | 1           | 4            | 1            | 2020-01-01  |
> | 2           | 1            | 5            | 2020-02-17  | 
> | 2           | 2            | 2            | 2020-02-01  | 
> | 2           | 3            | 2            | 2020-03-01  |
> | 3           | 1            | 3            | 2020-02-22  | 
> | 3           | 2            | 4            | 2020-02-25  | 
> +-------------+--------------+--------------+-------------+
> ```
>
> Output:
>
> ```
> +--------------+
> | results      |
> +--------------+
> | Daniel       |
> | Frozen 2     |
> +--------------+
> ```
>
> **Explanation:**
>
> - Daniel and Monica have rated 3 movies ("Avengers", "Frozen 2" and "Joker") but Daniel is smaller lexicographically.
> - Frozen 2 and Joker have a rating average of 3.5 in February but Frozen 2 is smaller lexicographically.

## Setup Soal

Buat tabel dan insert data contoh:

```sql
CREATE TABLE Movies (
    movie_id INT PRIMARY KEY,
    title VARCHAR(100) UNIQUE
);

CREATE TABLE Users (
    user_id INT PRIMARY KEY,
    name VARCHAR(100) UNIQUE
);

CREATE TABLE MovieRating (
    movie_id INT,
    user_id INT,
    rating INT,
    created_at DATE,
    PRIMARY KEY (movie_id, user_id),
    FOREIGN KEY (movie_id) REFERENCES Movies(movie_id),
    FOREIGN KEY (user_id) REFERENCES Users(user_id)
);

INSERT INTO Movies (movie_id, title) VALUES
    (1, 'Avengers'),
    (2, 'Frozen 2'),
    (3, 'Joker');

INSERT INTO Users (user_id, name) VALUES
    (1, 'Daniel'),
    (2, 'Monica'),
    (3, 'Maria'),
    (4, 'James');

INSERT INTO MovieRating (movie_id, user_id, rating, created_at) VALUES
    (1, 1, 3, '2020-01-12'),
    (1, 2, 4, '2020-02-11'),
    (1, 3, 2, '2020-02-12'),
    (1, 4, 1, '2020-01-01'),
    (2, 1, 5, '2020-02-17'),
    (2, 2, 2, '2020-02-01'),
    (2, 3, 2, '2020-03-01'),
    (3, 1, 3, '2020-02-22'),
    (3, 2, 4, '2020-02-25');
```

## Jawaban SQL

```sql "DATE_TRUNC" "UNION ALL"
WITH u AS (
    SELECT
        u.name,
        COUNT(*) AS mr_count
    FROM Users u
    JOIN MovieRating mr ON u.user_id = mr.user_id
    GROUP BY u.name
    ORDER BY mr_count DESC, u.name ASC
    LIMIT 1
),
m AS (
    SELECT
        m.title,
        AVG(rating::NUMERIC) AS avg_rating
    FROM Movies m
    JOIN MovieRating mr ON m.movie_id = mr.movie_id
    WHERE DATE_TRUNC('month', created_at) = '2020-02-01'::DATE
    GROUP BY m.title
    ORDER BY avg_rating DESC, m.title ASC
    LIMIT 1
)
SELECT name AS results FROM u
UNION ALL
SELECT title AS results FROM m;
```

## Penjelasan

Soal ini punya **2 pertanyaan berbeda** yang harus digabungkan dalam 1 output:

1. User dengan review terbanyak
2. Movie dengan rating tertinggi di February 2020

### CTE 1: User dengan Review Terbanyak

```sql
WITH u AS (
    SELECT
        u.name,
        COUNT(*) AS mr_count
    FROM Users u
    JOIN MovieRating mr ON u.user_id = mr.user_id
    GROUP BY u.name
    ORDER BY mr_count DESC, u.name ASC
    LIMIT 1
)
```

**JOIN Users dengan MovieRating**: Gabungkan data user dengan review mereka.

**COUNT(\*)**: Hitung jumlah review per user.

**ORDER BY mr_count DESC, u.name ASC**: Urutkan berdasarkan:
1. Jumlah review (descending) → user dengan review terbanyak di atas
2. Nama user (ascending) → jika tie, yang alphabetically lebih kecil di atas

**LIMIT 1**: Ambil 1 user teratas.

**Hasil**:

```
Daniel:  3 reviews (Avengers, Frozen 2, Joker)
Monica:  3 reviews (Avengers, Frozen 2, Joker)
```

Tie! Keduanya punya 3 reviews, tapi **Daniel** lebih kecil alphabetically.

### CTE 2: Movie dengan Rating Tertinggi di February 2020

```sql
m AS (
    SELECT
        m.title,
        AVG(rating::NUMERIC) AS avg_rating
    FROM Movies m
    JOIN MovieRating mr ON m.movie_id = mr.movie_id
    WHERE DATE_TRUNC('month', created_at) = '2020-02-01'::DATE
    GROUP BY m.title
    ORDER BY avg_rating DESC, m.title ASC
    LIMIT 1
)
```

**DATE_TRUNC('month', created_at)**: Truncate tanggal ke awal bulan.

- `2020-02-11` → `2020-02-01`
- `2020-02-25` → `2020-02-01`
- `2020-03-01` → `2020-03-01`

**Filter February 2020**: `DATE_TRUNC(...) = '2020-02-01'`

**Reviews di February 2020**:

```
Avengers:  rating 4, 2 (avg = 3.0)
Frozen 2:  rating 5, 2 (avg = 3.5)
Joker:     rating 3, 4 (avg = 3.5)
```

**ORDER BY avg_rating DESC, m.title ASC**: Urutkan berdasarkan:
1. Rating rata-rata (descending) → movie dengan rating tertinggi di atas
2. Judul movie (ascending) → jika tie, yang alphabetically lebih kecil di atas

**LIMIT 1**: Ambil 1 movie teratas.

**Hasil**: Frozen 2 dan Joker tie (avg = 3.5), tapi **Frozen 2** lebih kecil alphabetically.

### UNION ALL: Gabungkan Hasil

```sql
SELECT name AS results FROM u
UNION ALL
SELECT title AS results FROM m
```

**UNION ALL** menggabungkan kedua CTE menjadi 1 kolom `results`:

```
+--------------+
| results      |
+--------------+
| Daniel       | ← dari CTE u
| Frozen 2     | ← dari CTE m
+--------------+
```

### Kenapa UNION ALL, Bukan UNION?

**UNION ALL**: Gabungkan semua baris tanpa cek duplikat (lebih cepat).

**UNION**: Gabungkan dan hilangkan duplikat (lebih lambat).

Dalam kasus ini, kedua CTE menghasilkan value yang berbeda (nama user vs nama movie), jadi tidak mungkin ada duplikat. Maka `UNION ALL` lebih efisien.

## Referensi

- `WITH ... AS (...)`: Membuat CTE (Common Table Expression) sebagai tabel sementara.
- Multiple CTE: Gunakan koma untuk membuat beberapa CTE dalam 1 query.
- `SELECT`: Memilih kolom yang akan ditampilkan.
- `FROM`: Menentukan tabel sumber data.
- `JOIN`: Menggabungkan dua tabel berdasarkan kondisi tertentu.
- `WHERE`: Memfilter baris berdasarkan kondisi.
- `GROUP BY`: Mengelompokkan baris berdasarkan nilai kolom tertentu.
- `ORDER BY ... DESC, ... ASC`: Mengurutkan dengan multiple kondisi.
- `LIMIT`: Membatasi jumlah baris yang dikembalikan.
- `COUNT()`: Menghitung jumlah baris dalam setiap grup.
- `AVG()`: Menghitung rata-rata nilai dalam setiap grup.
- `DATE_TRUNC(unit, date)`: Truncate tanggal ke unit tertentu (year, month, day, dll).
- `UNION ALL`: Menggabungkan hasil dari 2+ query tanpa menghilangkan duplikat.
- `::NUMERIC`: Cast value ke tipe data numeric untuk pembagian decimal yang akurat.
- `AS`: Memberi alias untuk kolom hasil query.
- Lexicographical Order: Urutan alphabetically (A sebelum B, dll).
- [Tipe Data Tanggal dan Waktu](../../basic/01-03-date-time-types)
- [Memahami 4 Jenis JOIN](../../basic/02-01-4-joins)
