---
title: Consecutive Numbers (LAG Window Function)
description: Consecutive Numbers (LAG Window Function)
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Medium" variant="note" />
<Badge text="Advanced Select and Joins" variant="note" />

Temukan angka yang muncul minimal 3 kali berturut-turut menggunakan window function `LAG()` yang bisa handle ID tidak urut.

https://leetcode.com/problems/consecutive-numbers

## Soal

> Table: `Logs`
>
> ```
> +-------------+---------+
> | Column Name | Type    |
> +-------------+---------+
> | id          | int     |
> | num         | varchar |
> +-------------+---------+
> ```
>
> In SQL, `id` is the primary key for this table.
>
> `id` is an autoincrement column starting from 1.

Find all numbers that appear at least three times consecutively.

Return the result table in any order.

The result format is in the following example.

> **Example 1:**
>
> Input:
>
> `Logs` table:
>
> ```
> +----+-----+
> | id | num |
> +----+-----+
> | 1  | 1   |
> | 2  | 1   |
> | 3  | 1   |
> | 4  | 2   |
> | 5  | 1   |
> | 6  | 2   |
> | 7  | 2   |
> +----+-----+
> ```
>
> Output:
>
> ```
> +-----------------+
> | ConsecutiveNums |
> +-----------------+
> | 1               |
> +-----------------+
> ```
>
> **Explanation:**
>
> 1 is the only number that appears consecutively for at least three times.

## Setup Soal

Buat tabel dan insert data contoh:

```sql
CREATE TABLE Logs (
    id INT PRIMARY KEY,
    num VARCHAR(10)
);

INSERT INTO Logs (id, num) VALUES
    (1, '1'),
    (2, '1'),
    (3, '1'),
    (4, '2'),
    (5, '1'),
    (6, '2'),
    (7, '2');
```

## Jawaban SQL

```sql "LAG(num, 1) OVER (ORDER BY id)" "LAG(num, 2) OVER (ORDER BY id)"
WITH logs_with_prev AS (
    SELECT
        num,
        LAG(num, 1) OVER (ORDER BY id) AS prev_1,
        LAG(num, 2) OVER (ORDER BY id) AS prev_2
    FROM Logs
)
SELECT DISTINCT num AS ConsecutiveNums
FROM logs_with_prev
WHERE num = prev_1 AND num = prev_2;
```

## Penjelasan

Solusi ini menggunakan **window function `LAG()`** untuk melihat nilai `num` di baris sebelumnya tanpa perlu self-join. Kita menggunakan **CTE** untuk membuat query lebih mudah dibaca.

### Apa itu LAG()?

`LAG()` adalah window function yang mengambil nilai dari baris **sebelumnya** dalam urutan tertentu.

**Syntax**:

```sql
LAG(column, offset) OVER (ORDER BY sort_column)
```

- `column`: Kolom yang ingin diambil nilainya
- `offset`: Berapa baris ke belakang (1 = baris sebelumnya, 2 = 2 baris sebelumnya)
- `ORDER BY`: Menentukan urutan baris

### Keuntungan Window Function vs Self-Join

| Aspek | Window Function (LAG) | Self-Join |
|-------|----------------------|-----------|
| **Performance** | Lebih cepat (1x scan) | Lebih lambat (3x scan) |
| **Readability** | Lebih mudah dibaca | Lebih kompleks |
| **Handle ID tidak urut** | ✓ Bisa | ✗ Tidak bisa |
| **Flexibility** | Lebih fleksibel | Terbatas |

Mari kita breakdown query-nya step by step:

### Langkah 1: CTE dengan LAG

```sql
WITH logs_with_prev AS (
    SELECT
        num,
        LAG(num, 1) OVER (ORDER BY id) AS prev_1,
        LAG(num, 2) OVER (ORDER BY id) AS prev_2
    FROM Logs
)
```

**LAG(num, 1)**: Ambil nilai `num` dari baris **1 baris sebelumnya**

**LAG(num, 2)**: Ambil nilai `num` dari baris **2 baris sebelumnya**

**OVER (ORDER BY id)**: Urutkan berdasarkan `id` untuk menentukan "baris sebelumnya"

**Data Logs**:

```
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
```

**Hasil CTE `logs_with_prev`**:

```
+----+-----+--------+--------+
| id | num | prev_1 | prev_2 |
+----+-----+--------+--------+
| 1  | 1   | NULL   | NULL   | ← Tidak ada baris sebelumnya
| 2  | 1   | 1      | NULL   | ← prev_1 = id 1
| 3  | 1   | 1      | 1      | ← prev_1 = id 2, prev_2 = id 1
| 4  | 2   | 1      | 1      | ← prev_1 = id 3, prev_2 = id 2
| 5  | 1   | 2      | 1      | ← prev_1 = id 4, prev_2 = id 3
| 6  | 2   | 1      | 2      | ← prev_1 = id 5, prev_2 = id 4
| 7  | 2   | 2      | 1      | ← prev_1 = id 6, prev_2 = id 5
+----+-----+--------+--------+
```

Penjelasan setiap baris:

- **Baris id=1**: Tidak ada baris sebelumnya → `prev_1 = NULL`, `prev_2 = NULL`
- **Baris id=2**: 1 baris sebelumnya (id=1) → `prev_1 = 1`, `prev_2 = NULL`
- **Baris id=3**: 1 baris sebelumnya (id=2) dan 2 baris sebelumnya (id=1) → `prev_1 = 1`, `prev_2 = 1`
- **Baris id=4**: prev_1 dari id=3 (num=1), prev_2 dari id=2 (num=1) → `prev_1 = 1`, `prev_2 = 1`
- Dan seterusnya...

### Langkah 2: Filter WHERE

```sql
SELECT DISTINCT num AS ConsecutiveNums
FROM logs_with_prev
WHERE num = prev_1 AND num = prev_2
```

Cari baris dimana `num` sama dengan 2 baris sebelumnya (3 baris berturut-turut dengan nilai sama).

**Dari hasil CTE, cek kondisi**:

```
+----+-----+--------+--------+  num = prev_1 AND num = prev_2?
| id | num | prev_1 | prev_2 |
+----+-----+--------+--------+
| 1  | 1   | NULL   | NULL   | ✗ (NULL tidak sama dengan 1)
| 2  | 1   | 1      | NULL   | ✗ (NULL tidak sama dengan 1)
| 3  | 1   | 1      | 1      | ✓ (1 = 1 AND 1 = 1)
| 4  | 2   | 1      | 1      | ✗ (2 ≠ 1)
| 5  | 1   | 2      | 1      | ✗ (1 ≠ 2)
| 6  | 2   | 1      | 2      | ✗ (2 ≠ 1)
| 7  | 2   | 2      | 1      | ✗ (2 ≠ 1)
+----+-----+--------+--------+
```

Hasil setelah filter:

```
+----+-----+
| id | num |
+----+-----+
| 3  | 1   |
+----+-----+
```

Baris id=3 memenuhi kriteria: `num = 1` muncul di id=1, 2, 3 (3 kali berturut-turut).

### Langkah 3: DISTINCT

`DISTINCT` digunakan untuk menghilangkan duplikat jika ada angka yang muncul lebih dari 3 kali berturut-turut.

Hasil akhir:

```
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
```

### Keuntungan LAG: Handle ID Tidak Urut

Solusi self-join bergantung pada asumsi bahwa ID urut (1, 2, 3, ...). Jika ada gap dalam ID, self-join akan gagal.

**Contoh Data dengan ID Tidak Urut**:

```
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 5  | 1   | ← Ada gap: id 3 dan 4 tidak ada
| 6  | 2   |
+----+-----+
```

**Dengan Self-Join** (❌ Salah):

```sql
-- Mencari l1.id + 1 = l2.id
-- id=1 + 1 = 2 ✓
-- id=2 + 1 = 3 ✗ (tidak ada id=3)
-- Hasilnya: Tidak akan mendeteksi (1,2,5) sebagai consecutive
```

Self-join akan gagal karena mencari `id=3` yang tidak ada.

**Dengan LAG** (✓ Benar):

```sql
LAG(num) OVER (ORDER BY id)
```

```
+----+-----+--------+--------+
| id | num | prev_1 | prev_2 |
+----+-----+--------+--------+
| 1  | 1   | NULL   | NULL   |
| 2  | 1   | 1      | NULL   |
| 5  | 1   | 1      | 1      | ✓ Tetap bisa mendeteksi!
| 6  | 2   | 1      | 1      |
+----+-----+--------+--------+
```

LAG tetap bisa mendeteksi 3 consecutive karena **hanya peduli urutan baris**, bukan nilai ID!

### Visualisasi Perbandingan

```
Data: [1] [1] [1] [2] [1] [2] [2]
ID:    1   2   3   4   5   6   7

Untuk id=3:
- prev_1 (LAG 1): id=2 → num=1
- prev_2 (LAG 2): id=1 → num=1
- current: id=3 → num=1

Check: 1 = 1 AND 1 = 1 → TRUE ✓
Hasil: num=1 muncul 3x consecutive
```

## Referensi

- `WITH ... AS (...)`: Membuat CTE (Common Table Expression) sebagai tabel sementara.
- `SELECT`: Memilih kolom yang akan ditampilkan.
- `FROM`: Menentukan tabel sumber data.
- `WHERE`: Memfilter baris berdasarkan kondisi.
- `DISTINCT`: Menghilangkan duplikat dari hasil query.
- `LAG(column, offset)`: Window function untuk mengambil nilai dari baris sebelumnya.
- `OVER (ORDER BY ...)`: Mendefinisikan window dan urutan untuk window function.
- Window Function: Fungsi yang melakukan kalkulasi pada sekumpulan baris yang terkait dengan baris saat ini.
- `AS`: Memberi alias untuk kolom hasil query.
- `AND`: Operator logika untuk menggabungkan beberapa kondisi.
- `NULL`: Nilai khusus yang merepresentasikan "tidak ada nilai".
