---
title: Not Boring Movies
description: Not Boring Movies
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Easy" variant="note" />
<Badge text="Basic Aggregate Functions" variant="note" />

Ambil film dengan `id` ganjil dan `description` bukan `'boring'`, lalu urutkan `rating` dari yang paling besar.

https://leetcode.com/problems/not-boring-movies

## Soal

> Table: `Cinema`
>
> ```
> +----------------+----------+
> | Column Name    | Type     |
> +----------------+----------+
> | id             | int      |
> | movie          | varchar  |
> | description    | varchar  |
> | rating         | float    |
> +----------------+----------+
> ```
>
> `id` is the primary key (column with unique values) for this table.
>
> Each row contains information about the name of a movie, its genre, and its rating.
>
> `rating` is a 2 decimal places float in the range [0, 10]

Write a solution to report the movies with an odd-numbered ID and a description that is not "boring".

Return the result table ordered by rating in descending order.

The result format is in the following example.

> Example 1:
>
> Input:
>
> `Cinema` table:
>
> ```
> +----+------------+-------------+--------+
> | id | movie      | description | rating |
> +----+------------+-------------+--------+
> | 1  | War        | great 3D    | 8.9    |
> | 2  | Science    | fiction     | 8.5    |
> | 3  | irish      | boring      | 6.2    |
> | 4  | Ice song   | Fantacy     | 8.6    |
> | 5  | House card | Interesting | 9.1    |
> +----+------------+-------------+--------+
> ```
>
> Output:
>
> ```
> +----+------------+-------------+--------+
> | id | movie      | description | rating |
> +----+------------+-------------+--------+
> | 5  | House card | Interesting | 9.1    |
> | 1  | War        | great 3D    | 8.9    |
> +----+------------+-------------+--------+
> ```
>
> Explanation:
>
> We have three movies with odd-numbered IDs: 1, 3, and 5. The movie with ID = 3 is boring so we do not include it in the answer.

## Setup Soal

```sql
CREATE TABLE Cinema (
    id INT PRIMARY KEY,
    movie VARCHAR(255),
    description VARCHAR(255),
    rating FLOAT
);

INSERT INTO Cinema (id, movie, description, rating) VALUES
    (1, 'War', 'great 3D', 8.9),
    (2, 'Science', 'fiction', 8.5),
    (3, 'irish', 'boring', 6.2),
    (4, 'Ice song', 'Fantacy', 8.6),
    (5, 'House card', 'Interesting', 9.1);
```

## Jawaban SQL

Jawabanmu sudah benar. Di PostgreSQL, versi yang paling umum biasanya pakai operator modulo `%` dan operator standar `<>`:

```sql
SELECT
    *
FROM Cinema
WHERE
    description <> 'boring'
    AND id % 2 = 1
ORDER BY
    rating DESC;
```

## Penjelasan

Kita butuh 2 filter, lalu sorting:

1. Filter `id` ganjil:

   - `id % 2 = 1` artinya sisa pembagian `id` dengan 2 adalah 1 → ganjil.

2. Filter `description` bukan `'boring'`:

   - `description <> 'boring'` memilih baris yang deskripsinya tidak sama dengan `'boring'`.

3. Urutkan dari `rating` paling tinggi:

   - `ORDER BY rating DESC`

Dengan data example:

- `id` ganjil: 1, 3, 5
- tapi `id = 3` punya `description = 'boring'` → dibuang
- sisa `id = 5` (9.1) dan `id = 1` (8.9) → urut `DESC` jadi 5 dulu, lalu 1.

## Referensi

- `WHERE`: Filter baris.
- Operator modulo `%` (atau `mod(a, b)`): Cek ganjil/genap.
- Operator tidak sama dengan `<>` (PostgreSQL juga menerima `!=`).
- `ORDER BY ... DESC`: Urut dari terbesar ke terkecil.
