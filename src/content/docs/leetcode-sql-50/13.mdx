---
title: Managers with at Least 5 Direct Reports
description: Managers with at Least 5 Direct Reports
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Medium" variant="note" />
<Badge text="Basic Joins" variant="note" />

Cari manager yang memiliki setidaknya 5 bawahan langsung menggunakan self-join dan `HAVING` untuk memfilter hasil aggregate.

https://leetcode.com/problems/managers-with-at-least-5-direct-reports

## Soal

> Table: `Employee`
>
> ```
> +-------------+---------+
> | Column Name | Type    |
> +-------------+---------+
> | id          | int     |
> | name        | varchar |
> | department  | varchar |
> | managerId   | int     |
> +-------------+---------+
> ```
>
> `id` is the primary key (column with unique values) for this table.
>
> Each row of this table indicates the name of an employee, their department, and the id of their manager.
>
> If `managerId` is null, then the employee does not have a manager.
>
> No employee will be the manager of themself.

Write a solution to find managers with at least **five direct reports**.

Return the result table in **any order**.

The result format is in the following example.

> **Example 1:**
>
> Input:
>
> `Employee` table:
>
> ```
> +-----+-------+------------+-----------+
> | id  | name  | department | managerId |
> +-----+-------+------------+-----------+
> | 101 | John  | A          | null      |
> | 102 | Dan   | A          | 101       |
> | 103 | James | A          | 101       |
> | 104 | Amy   | A          | 101       |
> | 105 | Anne  | A          | 101       |
> | 106 | Ron   | B          | 101       |
> +-----+-------+------------+-----------+
> ```
>
> Output:
>
> ```
> +------+
> | name |
> +------+
> | John |
> +------+
> ```

## Setup Soal

Buat tabel dan insert data contoh:

```sql
CREATE TABLE Employee (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    department VARCHAR(255),
    managerId INT
);

INSERT INTO Employee (id, name, department, managerId) VALUES
    (101, 'John', 'A', NULL),
    (102, 'Dan', 'A', 101),
    (103, 'James', 'A', 101),
    (104, 'Amy', 'A', 101),
    (105, 'Anne', 'A', 101),
    (106, 'Ron', 'B', 101);
```

## Jawaban SQL

```sql "HAVING COUNT(e1.id) >= 5"
SELECT e1.name
FROM Employee e1
    INNER JOIN Employee e2 ON e1.id = e2.managerId
GROUP BY e1.id, e1.name
HAVING COUNT(e1.id) >= 5;
```

## Penjelasan

Soal ini meminta kita mencari manager yang memiliki setidaknya 5 bawahan langsung. Kita perlu menghitung berapa banyak employee yang memiliki `managerId` yang sama dengan `id` manager tersebut.

Mari kita breakdown query-nya step by step:

1. **Self-join**: `FROM Employee e1 INNER JOIN Employee e2 ON e1.id = e2.managerId` melakukan self-join pada tabel `Employee`.

   - `e1` mewakili manager (tabel kiri)
   - `e2` mewakili employee/bawahan (tabel kanan)
   - Kondisi join: `e1.id = e2.managerId` - mencocokkan `id` manager dengan `managerId` dari employee

   > **Note:** Ini disebut self-join karena kita join tabel dengan dirinya sendiri. Kita menggunakan `INNER JOIN` karena kita hanya ingin manager yang benar-benar punya bawahan.

   Setelah INNER JOIN, hasilnya akan seperti ini:

   ```
   +-------+---------+---------------+--------------+-------+---------+---------------+--------------+
   | e1.id | e1.name | e1.department | e1.managerId | e2.id | e2.name | e2.department | e2.managerId |
   +-------+---------+---------------+--------------+-------+---------+---------------+--------------+
   | 101   | John    | A             | NULL         | 102   | Dan     | A             | 101          |
   | 101   | John    | A             | NULL         | 103   | James   | A             | 101          |
   | 101   | John    | A             | NULL         | 104   | Amy     | A             | 101          |
   | 101   | John    | A             | NULL         | 105   | Anne    | A             | 101          |
   | 101   | John    | A             | NULL         | 106   | Ron     | B             | 101          |
   +-------+---------+---------------+--------------+-------+---------+---------------+--------------+
   ```

   Perhatikan bahwa:

   - John (id = 101) muncul 5 kali karena ada 5 employee yang memiliki `managerId = 101`
   - Tidak ada manager lain yang muncul karena hanya John yang punya bawahan

2. **GROUP BY**: `GROUP BY e1.id, e1.name` mengelompokkan baris berdasarkan manager. Setiap grup mewakili satu manager dan semua bawahannya.

3. **COUNT dan HAVING**: `HAVING COUNT(e1.id) >= 5` menghitung jumlah bawahan untuk setiap manager dan hanya mengambil manager yang memiliki setidaknya 5 bawahan.

   > **Perbedaan `HAVING` vs `WHERE`:**
   >
   > - `WHERE`: Memfilter baris **sebelum** aggregate (sebelum `GROUP BY`)
   > - `HAVING`: Memfilter hasil **setelah** aggregate (setelah `GROUP BY`)
   >
   > Karena kita perlu memfilter berdasarkan hasil `COUNT()` yang merupakan fungsi aggregate, kita **harus** menggunakan `HAVING`, bukan `WHERE`.

   Setelah GROUP BY dan COUNT, hasilnya akan seperti ini:

   ```
   +-------+---------+--------------+
   | e1.id | e1.name | COUNT(e1.id) |
   +-------+---------+--------------+
   | 101   | John    | 5            |
   +-------+---------+--------------+
   ```

   John memiliki 5 bawahan, jadi memenuhi kondisi `>= 5`.

4. **SELECT**: `SELECT e1.name` menampilkan nama manager yang memenuhi kondisi.

Hasil akhir: John, karena dia memiliki 5 bawahan langsung (Dan, James, Amy, Anne, dan Ron).

> Kalau kamu masih bingung dengan `JOIN` dan kenapa menggunakan `INNER JOIN`, coba baca dulu materi ini yaa!
> [Memahami 4 Jenis JOIN](../../basic/02-01-4-joins)

## Referensi

- `SELECT`: Memilih kolom yang akan ditampilkan.
- `FROM`: Menentukan tabel sumber data utama.
- `INNER JOIN`: Menggabungkan dua tabel dengan hanya mengambil baris yang cocok di kedua tabel.
- Self-Join: Teknik join tabel dengan dirinya sendiri, biasanya dengan alias yang berbeda untuk membedakan peran masing-masing.
- `ON`: Menentukan kondisi untuk menggabungkan baris dari kedua tabel.
- `GROUP BY`: Mengelompokkan baris berdasarkan nilai kolom tertentu.
- `COUNT()`: Menghitung jumlah baris dalam setiap grup.
- `HAVING`: Memfilter hasil setelah aggregate (setelah `GROUP BY`). Berbeda dengan `WHERE` yang memfilter sebelum aggregate.
- `>=`: Operator perbandingan untuk "lebih besar atau sama dengan".
- `AS` / Alias: Memberi nama singkat untuk tabel (contoh: `e1` untuk manager, `e2` untuk employee).
- [Memahami 4 Jenis JOIN](../../basic/02-01-4-joins)
