---
title: Primary Department for Each Employee
description: Primary Department for Each Employee
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Easy" variant="note" />
<Badge text="Advanced Select and Joins" variant="note" />

Temukan primary department setiap employee menggunakan `UNION`, `WHERE`, `GROUP BY`, dan `HAVING`.

https://leetcode.com/problems/primary-department-for-each-employee

## Soal

> Table: `Employee`
>
> ```
> +---------------+---------+
> | Column Name   |  Type   |
> +---------------+---------+
> | employee_id   | int     |
> | department_id | int     |
> | primary_flag  | varchar |
> +---------------+---------+
> ```
>
> (`employee_id`, `department_id`) is the primary key (combination of columns with unique values) for this table.
>
> `employee_id` is the id of the employee.
>
> `department_id` is the id of the department to which the employee belongs.
>
> `primary_flag` is an ENUM (category) of type ('Y', 'N'). If the flag is 'Y', the department is the primary department for the employee. If the flag is 'N', the department is not the primary.

Employees can belong to multiple departments. When the employee joins other departments, they need to decide which department is their primary department. Note that when an employee belongs to only one department, their primary column is 'N'.

Write a solution to report all the employees with their primary department. For employees who belong to one department, report their only department.

Return the result table in any order.

The result format is in the following example.

> **Example 1:**
>
> Input:
>
> `Employee` table:
>
> ```
> +-------------+---------------+--------------+
> | employee_id | department_id | primary_flag |
> +-------------+---------------+--------------+
> | 1           | 1             | N            |
> | 2           | 1             | Y            |
> | 2           | 2             | N            |
> | 3           | 3             | N            |
> | 4           | 2             | N            |
> | 4           | 3             | Y            |
> | 4           | 4             | N            |
> +-------------+---------------+--------------+
> ```
>
> Output:
>
> ```
> +-------------+---------------+
> | employee_id | department_id |
> +-------------+---------------+
> | 1           | 1             |
> | 2           | 1             |
> | 3           | 3             |
> | 4           | 3             |
> +-------------+---------------+
> ```
>
> **Explanation:**
>
> - The Primary department for employee 1 is 1.
> - The Primary department for employee 2 is 1.
> - The Primary department for employee 3 is 3.
> - The Primary department for employee 4 is 3.

## Setup Soal

Buat tabel dan insert data contoh:

```sql
CREATE TABLE Employee (
    employee_id INT,
    department_id INT,
    primary_flag VARCHAR(1) CHECK (primary_flag IN ('Y', 'N')),
    PRIMARY KEY (employee_id, department_id)
);

INSERT INTO Employee (employee_id, department_id, primary_flag) VALUES
    (1, 1, 'N'),
    (2, 1, 'Y'),
    (2, 2, 'N'),
    (3, 3, 'N'),
    (4, 2, 'N'),
    (4, 3, 'Y'),
    (4, 4, 'N');
```

## Jawaban SQL

```sql "UNION" "primary_flag = 'Y'" "HAVING COUNT(*) = 1"
SELECT employee_id, department_id
FROM Employee
WHERE primary_flag = 'Y'

UNION 

SELECT employee_id, MIN(department_id)
FROM Employee
GROUP BY employee_id
HAVING COUNT(*) = 1;
```

## Penjelasan

Soal ini meminta kita untuk menemukan **primary department** setiap employee dengan 2 kondisi:

1. **Jika employee punya banyak department**: Ambil department dengan `primary_flag = 'Y'`
2. **Jika employee hanya punya 1 department**: Ambil department tersebut (meskipun flag-nya 'N')

Query ini menggunakan **UNION** untuk menggabungkan 2 kasus tersebut.

Mari kita breakdown query-nya:

### Bagian 1: Employee dengan Primary Flag = 'Y'

```sql
SELECT employee_id, department_id
FROM Employee
WHERE primary_flag = 'Y'
```

Filter employee yang punya department dengan `primary_flag = 'Y'`.

**Data Employee**:

```
+-------------+---------------+--------------+
| employee_id | department_id | primary_flag |
+-------------+---------------+--------------+
| 1           | 1             | N            |
| 2           | 1             | Y            | ✓
| 2           | 2             | N            |
| 3           | 3             | N            |
| 4           | 2             | N            |
| 4           | 3             | Y            | ✓
| 4           | 4             | N            |
+-------------+---------------+--------------+
```

**Hasil Bagian 1**:

```
+-------------+---------------+
| employee_id | department_id |
+-------------+---------------+
| 2           | 1             |
| 4           | 3             |
+-------------+---------------+
```

### Bagian 2: Employee yang Hanya Punya 1 Department

```sql
SELECT employee_id, MIN(department_id)
FROM Employee
GROUP BY employee_id
HAVING COUNT(*) = 1
```

**GROUP BY employee_id**: Kelompokkan berdasarkan employee.

```
+-------------+----------------+-------+
| employee_id | department_ids | count |
+-------------+----------------+-------+
| 1           | [1]            | 1     | ← Hanya 1 department
| 2           | [1, 2]         | 2     |
| 3           | [3]            | 1     | ← Hanya 1 department
| 4           | [2, 3, 4]      | 3     |
+-------------+----------------+-------+
```

**HAVING COUNT(\*) = 1**: Filter hanya employee yang punya 1 department.

```
+-------------+----------------+
| employee_id | department_ids |
+-------------+----------------+
| 1           | [1]            |
| 3           | [3]            |
+-------------+----------------+
```

**MIN(department_id)**: Ambil department_id (karena cuma 1, MIN sama dengan nilai itu sendiri).

**Hasil Bagian 2**:

```
+-------------+---------------+
| employee_id | department_id |
+-------------+---------------+
| 1           | 1             |
| 3           | 3             |
+-------------+---------------+
```

### UNION: Gabungkan Kedua Hasil

```sql
Bagian 1                      UNION         Bagian 2
+-------------+---------------+          +-------------+---------------+
| employee_id | department_id |          | employee_id | department_id |
+-------------+---------------+          +-------------+---------------+
| 2           | 1             |          | 1           | 1             |
| 4           | 3             |          | 3           | 3             |
+-------------+---------------+          +-------------+---------------+
```

**UNION** menggabungkan kedua hasil dan **menghilangkan duplikat** (jika ada).

Hasil akhir:

```
+-------------+---------------+
| employee_id | department_id |
+-------------+---------------+
| 1           | 1             |
| 2           | 1             |
| 3           | 3             |
| 4           | 3             |
+-------------+---------------+
```

### Penjelasan Detail per Employee

**Employee 1**:
- Total department: 1 (department 1)
- Primary flag: 'N'
- **Logika**: Karena hanya punya 1 department, ambil department tersebut → **department 1** ✓ (dari Bagian 2)

**Employee 2**:
- Total department: 2 (department 1 dan 2)
- Primary flag: 'Y' di department 1
- **Logika**: Karena punya lebih dari 1 department, ambil yang primary_flag = 'Y' → **department 1** ✓ (dari Bagian 1)

**Employee 3**:
- Total department: 1 (department 3)
- Primary flag: 'N'
- **Logika**: Karena hanya punya 1 department, ambil department tersebut → **department 3** ✓ (dari Bagian 2)

**Employee 4**:
- Total department: 3 (department 2, 3, 4)
- Primary flag: 'Y' di department 3
- **Logika**: Karena punya lebih dari 1 department, ambil yang primary_flag = 'Y' → **department 3** ✓ (dari Bagian 1)

### Kenapa Pakai MIN di Bagian 2?

Karena employee di Bagian 2 pasti hanya punya **1 department**, `MIN(department_id)` akan mengembalikan department_id tersebut.

Kita juga bisa pakai:
- `MAX(department_id)` → Hasilnya sama karena cuma 1 nilai
- `ANY_VALUE(department_id)` → Ambil nilai apapun (PostgreSQL 16+)

Tapi `MIN` adalah pilihan yang paling umum dan aman.

### UNION vs UNION ALL

**UNION**:
- Menggabungkan hasil dan **menghilangkan duplikat**
- Lebih lambat karena perlu cek duplikat

**UNION ALL**:
- Menggabungkan hasil **tanpa** menghilangkan duplikat
- Lebih cepat

Untuk soal ini, **UNION** atau **UNION ALL** keduanya benar karena Bagian 1 dan Bagian 2 tidak akan menghasilkan duplikat (employee yang punya banyak department pasti punya primary_flag = 'Y', dan tidak akan masuk ke Bagian 2).

## Referensi

- `SELECT`: Memilih kolom yang akan ditampilkan.
- `FROM`: Menentukan tabel sumber data.
- `WHERE`: Memfilter baris berdasarkan kondisi.
- `GROUP BY`: Mengelompokkan baris berdasarkan nilai kolom tertentu.
- `HAVING`: Memfilter grup berdasarkan kondisi agregat.
- `COUNT()`: Menghitung jumlah baris dalam setiap grup.
- `MIN()`: Mengembalikan nilai terkecil dalam setiap grup.
- `UNION`: Menggabungkan hasil dari 2+ query dan menghilangkan duplikat.
- `UNION ALL`: Menggabungkan hasil dari 2+ query tanpa menghilangkan duplikat.
- ENUM Type: Tipe data yang hanya bisa menerima nilai tertentu.
- Primary Key Komposit: Primary key yang terdiri dari kombinasi beberapa kolom.
