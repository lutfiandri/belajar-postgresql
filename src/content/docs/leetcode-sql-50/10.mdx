---
title: Average Time of Process per Machine
description: Average Time of Process per Machine
---

import { Badge } from "@astrojs/starlight/components";

<Badge text="Easy" variant="note" />
<Badge text="Basic Joins" variant="note" />
<Badge text="Aggregate Functions" variant="note" />

Hitung rata-rata waktu yang dibutuhkan setiap mesin untuk menyelesaikan proses menggunakan self-join untuk mencocokkan `start` dan `end`, lalu gunakan `AVG()` dan `ROUND()`.

https://leetcode.com/problems/average-time-of-process-per-machine

## Soal

> Table: `Activity`
>
> ```
> +----------------+---------+
> | Column Name    | Type    |
> +----------------+---------+
> | machine_id     | int     |
> | process_id     | int     |
> | activity_type  | enum    |
> | timestamp      | float   |
> +----------------+---------+
> ```
>
> The table shows the user activities for a factory website.
>
> (`machine_id`, `process_id`, `activity_type`) is the primary key (combination of columns with unique values) of this table.
>
> `machine_id` is the ID of a machine.
>
> `process_id` is the ID of a process running on the machine with ID `machine_id`.
>
> `activity_type` is an ENUM (category) of type ('start', 'end').
>
> `timestamp` is a float representing the current time in seconds.
>
> 'start' means the machine starts the process at the given timestamp and 'end' means the machine ends the process at the given timestamp.
>
> The 'start' timestamp will always be before the 'end' timestamp for every (`machine_id`, `process_id`) pair.
>
> It is guaranteed that each (`machine_id`, `process_id`) pair has a 'start' and 'end' timestamp.

There is a factory website that has several machines each running the same number of processes. Write a solution to find the average time each machine takes to complete a process.

The time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.

The resulting table should have the `machine_id` along with the average time as `processing_time`, which should be rounded to 3 decimal places.

Return the result table in **any order**.

The result format is in the following example.

> **Example 1:**
>
> Input:
>
> `Activity` table:
>
> ```
> +------------+------------+---------------+-----------+
> | machine_id | process_id | activity_type | timestamp |
> +------------+------------+---------------+-----------+
> | 0          | 0          | start         | 0.712     |
> | 0          | 0          | end           | 1.520     |
> | 0          | 1          | start         | 3.140     |
> | 0          | 1          | end           | 4.120     |
> | 1          | 0          | start         | 0.550     |
> | 1          | 0          | end           | 1.550     |
> | 1          | 1          | start         | 0.430     |
> | 1          | 1          | end           | 1.420     |
> | 2          | 0          | start         | 4.100     |
> | 2          | 0          | end           | 4.512     |
> | 2          | 1          | start         | 2.500     |
> | 2          | 1          | end           | 5.000     |
> +------------+------------+---------------+-----------+
> ```
>
> Output:
>
> ```
> +------------+-----------------+
> | machine_id | processing_time |
> +------------+-----------------+
> | 0          | 0.894           |
> | 1          | 0.995           |
> | 2          | 1.456           |
> +------------+-----------------+
> ```
>
> Explanation:
>
> - There are 3 machines running 2 processes each.
> - Machine 0's average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894
> - Machine 1's average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995
> - Machine 2's average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456

## Setup Soal

Buat tabel dan insert data contoh:

```sql
CREATE TABLE Activity (
    machine_id INT,
    process_id INT,
    activity_type VARCHAR(10) CHECK (activity_type IN ('start', 'end')),
    timestamp FLOAT,
    PRIMARY KEY (machine_id, process_id, activity_type)
);

INSERT INTO Activity (machine_id, process_id, activity_type, timestamp) VALUES
    (0, 0, 'start', 0.712),
    (0, 0, 'end', 1.520),
    (0, 1, 'start', 3.140),
    (0, 1, 'end', 4.120),
    (1, 0, 'start', 0.550),
    (1, 0, 'end', 1.550),
    (1, 1, 'start', 0.430),
    (1, 1, 'end', 1.420),
    (2, 0, 'start', 4.100),
    (2, 0, 'end', 4.512),
    (2, 1, 'start', 2.500),
    (2, 1, 'end', 5.000);
```

## Jawaban SQL

```sql "a1.activity_type = 'start'" "a2.activity_type = 'end'" "AVG(a2.timestamp - a1.timestamp)::numeric"  "GROUP BY a1.machine_id"
SELECT
    a1.machine_id,
    ROUND(AVG(a2.timestamp - a1.timestamp)::numeric, 3) AS processing_time
FROM Activity a1
    JOIN Activity a2
        ON a1.machine_id = a2.machine_id
        AND a1.process_id = a2.process_id
WHERE a1.activity_type = 'start'
    AND a2.activity_type = 'end'
GROUP BY a1.machine_id;
```

## Penjelasan

Soal ini meminta kita menghitung rata-rata waktu yang dibutuhkan setiap mesin untuk menyelesaikan proses. Waktu proses dihitung dari selisih antara timestamp 'end' dan 'start' untuk setiap (`machine_id`, `process_id`).

Mari kita breakdown query-nya step by step:

1. `FROM Activity a1 JOIN Activity a2 ON ...`: Kita melakukan self-join pada tabel `Activity` untuk mencocokkan baris berdasarkan `machine_id` dan `process_id`.

   - `a1` mewakili aktivitas 'start'
   - `a2` mewakili aktivitas 'end'
   - Kondisi join di `ON`:
     - `a1.machine_id = a2.machine_id`: Mesin harus sama
     - `a1.process_id = a2.process_id`: Proses harus sama

2. `WHERE a1.activity_type = 'start' AND a2.activity_type = 'end'`: Setelah join, kita filter hanya baris di mana `a1` adalah 'start' dan `a2` adalah 'end'. Ini memastikan kita hanya menghitung pasangan start-end yang benar.

   > **Note:** Ini adalah self-join dengan `INNER JOIN` (bisa ditulis `JOIN` saja). Kita hanya perlu baris yang punya pasangan 'start' dan 'end', jadi tidak perlu `LEFT JOIN`. Kondisi `activity_type` bisa diletakkan di `ON` atau `WHERE` - untuk `INNER JOIN`, hasilnya sama, tapi `WHERE` lebih jelas menunjukkan bahwa ini adalah filter setelah join.

   Setelah JOIN, kita dapat pasangan start-end untuk setiap proses:

   ```
   +---------------+---------------+------------------+--------------+---------------+---------------+------------------+--------------+
   | a1.machine_id | a1.process_id | a1.activity_type | a1.timestamp | a2.machine_id | a2.process_id | a2.activity_type | a2.timestamp |
   +---------------+---------------+------------------+--------------+---------------+---------------+------------------+--------------+
   | 0             | 0             | start            | 0.712        | 0             | 0             | end              | 1.520        |
   | 0             | 1             | start            | 3.140        | 0             | 1             | end              | 4.120        |
   | 1             | 0             | start            | 0.550        | 1             | 0             | end              | 1.550        |
   | 1             | 1             | start            | 0.430        | 1             | 1             | end              | 1.420        |
   | 2             | 0             | start            | 4.100        | 2             | 0             | end              | 4.512        |
   | 2             | 1             | start            | 2.500        | 2             | 1             | end              | 5.000        |
   +---------------+---------------+------------------+--------------+---------------+---------------+------------------+--------------+
   ```

3. `AVG(a2.timestamp - a1.timestamp)`: Hitung rata-rata selisih waktu untuk setiap mesin. `a2.timestamp - a1.timestamp` menghasilkan waktu yang dibutuhkan untuk menyelesaikan proses.

4. `ROUND(...::numeric, 3)`: Bulatkan hasil ke 3 desimal. Di PostgreSQL, `ROUND()` memerlukan tipe data `NUMERIC`, bukan `FLOAT`. Karena hasil dari `AVG()` adalah `FLOAT`, maka perlu casting ke `NUMERIC` terlebih dahulu menggunakan `::numeric`.

   > Jika kamu masih bingung casting tipe data, baca materi ini yaa!
   > [Casting Tipe Data](../../basic/06-casting-types)

5. `GROUP BY a1.machine_id`: Kelompokkan hasil berdasarkan `machine_id` agar `AVG()` menghitung rata-rata per mesin.

6. `SELECT a1.machine_id, ... AS processing_time`: Tampilkan `machine_id` dan rata-rata waktu sebagai `processing_time`.

Dari contoh data:

- Machine 0: Process 0 = 1.520 - 0.712 = 0.808, Process 1 = 4.120 - 3.140 = 0.980 → Rata-rata = (0.808 + 0.980) / 2 = 0.894
- Machine 1: Process 0 = 1.550 - 0.550 = 1.000, Process 1 = 1.420 - 0.430 = 0.990 → Rata-rata = (1.000 + 0.990) / 2 = 0.995
- Machine 2: Process 0 = 4.512 - 4.100 = 0.412, Process 1 = 5.000 - 2.500 = 2.500 → Rata-rata = (0.412 + 2.500) / 2 = 1.456

Hasil akhir sesuai dengan output contoh.

> Kalau kamu masih bingung dengan `JOIN` dan kenapa menggunakan `INNER JOIN`, coba baca dulu materi ini yaa!
> [Memahami 4 Jenis JOIN](../../basic/01-join)

## Referensi

- `SELECT`: Memilih kolom yang akan ditampilkan.
- `FROM`: Menentukan tabel sumber data utama.
- `JOIN` / `INNER JOIN`: Menggabungkan dua tabel dengan hanya mengambil baris yang cocok di kedua tabel.
- Self-Join: Teknik join tabel dengan dirinya sendiri, biasanya dengan alias yang berbeda untuk membedakan peran masing-masing.
- `ON`: Menentukan kondisi untuk menggabungkan baris dari kedua tabel.
- `AND`: Menggabungkan beberapa kondisi dalam `ON` atau `WHERE`.
- `AVG()`: Menghitung rata-rata nilai dalam grup.
- `ROUND()`: Membulatkan nilai numerik ke jumlah desimal tertentu.
- `::numeric`: Casting tipe data ke `numeric` di PostgreSQL.
- `GROUP BY`: Mengelompokkan baris berdasarkan nilai kolom tertentu.
- `AS`: Memberi alias untuk kolom hasil query.
- Operasi aritmatika pada kolom: Bisa melakukan pengurangan, penjumlahan, dll pada kolom numerik.
- [Memahami 4 Jenis JOIN](../../basic/01-join)
- [Casting Tipe Data](../../basic/06-casting-types)
